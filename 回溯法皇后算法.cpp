#include<stdio.h>
#include<cmath>
#define n 8 //棋盘大小 
int queen[n+1];//皇后的摆放位置数组 

int num=0; 
void show(){ /*输出所有皇后的摆放方案*/
	int i;
	
	for(i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(j==queen[i]){
				printf("%d ",queen[i]);
			}
			else{
				printf("0 ");
			}
		}
		printf("\n");		
	}
	printf("-----------------------------");	
	printf("\n");
} 

int Place(int j){
	//检查当前列是否可以放置皇后，不能放返回0，能放返回1 
	int i;
	for(i=1;i<j;i++){
		if( queen[i]==queen[j]|| abs(queen[i]-queen[j])==(j-i) ){
		//是否与已摆好的皇后在同一列或者同一斜线上 
			return 0;
		}
	}
	return 1;
}

void Nqueen(int j){
	int i;
	for(i=1;i<=n;i++){
		queen[j]=i;
		//这一步开始，直接让 queen[j]==i，若是下面if判断正确，这下一个Nqueen，否则继续让queen[j]等于下一个i直到满足为止 
		if(Place(j)&&j<=n){
			if(j==n){//是否已经摆放完毕，若是已经摆放完毕就输出表格，若是没有继续摆放棋子 
				num=num+1;
				if(num<=3){
					show();
					//如果所有皇后都摆放好，就输出当前摆放方案 
					//只输出前三个就够了，不然太多了 
				} 
			 
			}else{
				Nqueen(j+1);//否则就继续摆放下一个皇后 
			}
		}
	}
} 

int main(){
	Nqueen(1);
	printf("一共有%d种解决方法",num);
	return 0;
} 

//这个n皇后问题都是几把辅料，真正的核心就是这个代码，看完后你就了解了最基本的回溯法思想
//这个函数并不会响应，只是我用来整理思想而已 
//中心思想是这样的，先给第一个位置设定一个符合逻辑的值，符合就继续递归下一个位置，若是以后的几个数据不符合就结束递归回来，再给第一个位置找下一个符合逻辑的值，直到能把所有的内容都输入到里面去。 
int zhuti( int j){
	int t=1;//随便一个判定条件而已，没什么逻辑，不用过于纠结
	 
	 //整个逻辑结构是这样的哈，你给数组的每一个位置不是循环加入一个适合的数嘛，若是适合就继续递归，给数组的下一个位置找合适的数，直到给所有的数都
	 //找到合适的数，若是不合适的呢，就返回到上一个递归函数里面，就会继续给数组的上一个位置再找一个合适的数，再在这个数的基础上给它递归下一个位置.这就是深度搜索的算法吧。 
	for(int i=1;i<n;i++){
		if(j<=n&&t=1){//当还没有遍历完毕的时候符合条件的时候 
			if(j!=n){//遍历没结束 
				zhuti(j+1);//继续找下一个位置 //输出结果 
			}
			else{
				//输出结果 
			}
		} 
	}
	
} 






















